# HTTP/浏览器

## 从地址栏输入URL到呈现页面

1. 浏览器向DNS服务器获取URL中域名对应的IP地址
2. 建立TCP连接
3. 浏览器发出读取文件的请求
4. 服务器对浏览器请求做出响应，并把对应的html文本发送给浏览器
5. 浏览器渲染HTML并显示
6. 释放TCP连接

## 三次握手作用

**第一次**：客户端向服务端发送请求建立连接

**第二次**：服务端接收到客户端的请求后向客户端发送响应，这时服务端知道了客户端可以正常发送请求

**第三次**：客户端接收到响应后再次向服务端发送请求，这时客户端知道了服务端可以正常的接收和发送，服务端知道了客户端也可以正常接收，连接建立成功

## 四次挥手

**第一次**：客户端数据发送完成，向服务端发送释放连接的请求

**第二次**：服务端接收到连接释放请求后，发送一个回复的响应进入CLOSE-WAIT状态，此时客户端到服务端的连接释放，不再接受客户端的数据，但是因为TCP连接是双向的，服务端仍旧可以发送数据到客户端

**第三次**：服务端如果还有没发送完的数据会继续发送，发送完毕后向客户端发送释放连接的请求，然后服务端进入LAST-ACK状态

**第四次**：客户端接收到请求后，向服务端发送应答，客户端进入TIME-WAIT状态，该状态会持续2MSL（2倍的报文在网络中的生存时间），若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。

四次挥手是因为TCP连接是全双工的，所以需要双方分别释放连接，单独一方的连接释放，只代表不能再向对方发送数据，连接处于的是半释放的状态。

最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器端不能正常关闭。

## HTTP缓存

- 判断是否过期（服务器会通知浏览器一个缓存时间，相关头部信息再Cache-Control和Expires中），如果时间未过期，则直接从缓存中取，即**强缓存**：

  Cache-Control

  - `max-age=<seconds>`缓存存储的最大周期，超过时间会被认为过期，时间相对于请求时间

  Expires

  - 规定了缓存的资源过期的时间，使用GMT标准时间格式，js可以通过`new Date().toUTCString()`得到，时间期限是服务器生成的，有误差，优先级比`cache-control`低

- 如果判断缓存时间已经过期，将会采用**协商缓存**，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串，资源从缓存中读取

  Last-Modified响应头和If-Modified-Since请求头

  Etag响应头和If-None-Match请求头

## HTTPS

https是安全版的http，因为http都是明文传输的，对于敏感信息的传输很不安全，https就是为了解决http的安全隐患而出现的

https的实现比较复杂，将对称加密的密钥使用非对称加密的公钥进行加密，在保证了通信效率的同时防止窃听，同时结合CA证书以及数字签名来最大程度的保证安全性

- 对称加密：通信双方都使用同一个密钥进行加密。这种方式虽然简单性能好，但是无法解决首次把密钥发给对方的问题，容易被黑客拦截密钥
- 非对称加密：由私钥+公钥组成的密钥对
  - 私钥加密的数据，只有公钥才能解密；公钥加密的数据，私钥才能解密
  - 通信双方都有自己的一套密钥对，通信前将自己的公钥发送给对方
  - 然后使用对方的公钥加密数据响应给对方，等对方收到后再用自己的私钥解密

非对称加密安全性更高，但是速度较慢，影响性能

https将两种方式结合起来，将对称加密的密钥使用非对称加密的公钥进行加密，然后再发送出去，接收方使用自己的私钥解密得到对称加密的密钥

> 中间人问题：如果此时在双方之间存在一中间人，将原本双方通信互发的公钥换成自己的公钥，就可以轻松破解双方发送的消息

这个时候就需要一个安全的第三方来证明身份，所以就有了CA证书

为了防止CA证书被篡改，使用了另一种保护方案：数字签名

数字签名就是使用证书自带的HASH算法对证书内容进行计算得到一个摘要，再用CA的私钥进行加密组成最终的数字签名

> 当别人把他的证书发过来时，用同样的HASH算法得到信息摘要，然后再用CA的公钥对数字签名进行解密，得到CA创建的消息摘要，两者一对比就知道中间有没有被篡改了

通过这样的方式，https最大化保证了通信的安全性
