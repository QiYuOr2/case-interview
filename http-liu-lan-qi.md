# HTTP/浏览器

## 从地址栏输入 URL 到呈现页面

1. 浏览器向 DNS 服务器获取 URL 中域名对应的 IP 地址
2. 建立 TCP 连接
3. 浏览器发出读取文件的请求
4. 服务器对浏览器请求做出响应，并把对应的 html 文本发送给浏览器
5. 浏览器渲染 HTML 并显示
6. 释放 TCP 连接

## 三次握手作用

**第一次**：客户端向服务端发送请求建立连接

**第二次**：服务端接收到客户端的请求后向客户端发送响应，这时服务端知道了客户端可以正常发送请求

**第三次**：客户端接收到响应后再次向服务端发送请求，这时客户端知道了服务端可以正常的接收和发送，服务端知道了客户端也可以正常接收，连接建立成功

## 四次挥手

**第一次**：客户端数据发送完成，向服务端发送释放连接的请求

**第二次**：服务端接收到连接释放请求后，发送一个回复的响应进入 CLOSE-WAIT 状态，此时客户端到服务端的连接释放，不再接受客户端的数据，但是因为 TCP 连接是双向的，服务端仍旧可以发送数据到客户端

**第三次**：服务端如果还有没发送完的数据会继续发送，发送完毕后向客户端发送释放连接的请求，然后服务端进入 LAST-ACK 状态

**第四次**：客户端接收到请求后，向服务端发送应答，客户端进入 TIME-WAIT 状态，该状态会持续 2MSL（2 倍的报文在网络中的生存时间），若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。

四次挥手是因为 TCP 连接是全双工的，所以需要双方分别释放连接，单独一方的连接释放，只代表不能再向对方发送数据，连接处于的是半释放的状态。

最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器端不能正常关闭。

## HTTP 缓存

### 强缓存

强制缓存就是文件直接从缓存中获取，不需要发送请求。

http1.0 时，使用 Expires 字段，表示文件过期时间（使用 GMT 标准时间格式，js 可以通过`new Date().toUTCString()`得到，时间期限是服务器生成的，有误差，优先级比`cache-control`低）

http1.1 引入了 cache-control

- max-age: 缓存过期时间，相对于请求时间（多少秒后过期）
- public: 表示客户端和代理服务器都会缓存
- private: 表示只在客户端缓存
- no-cache: 协商缓存标识符，表示文件会被缓存但是需要和服务器协商
- no-store: 表示文件不会被缓存

### 协商缓存

协商缓存就是文件已经被缓存了，但是否从缓存中读取是需要和服务器进行协商，具体如何协商要看请求头/响应头的字段设置。( 如果协商缓存命中，请求响应返回的 http 状态为 304 并且会显示一个 Not Modified 的字符串，资源从缓存中读取）

利用 Last-Modified/if-Modified-Since 和 Etag/if-None-Match 这两对响应/请求头

**Last-Modified/If-Modified-Since**
Last-Modified 包含了上次更改文档的日期

**Etag/If-None-Match**
Etag 是被请求变量的实体标记，与请求头携带的 If-None-Match 进行对比可以判断资源是否发生变化

## HTTPS

https 是安全版的 http，因为 http 都是明文传输的，对于敏感信息的传输很不安全，https 就是为了解决 http 的安全隐患而出现的

https 的实现比较复杂，将对称加密的密钥使用非对称加密的公钥进行加密，在保证了通信效率的同时防止窃听，同时结合 CA 证书以及数字签名来最大程度的保证安全性

- 对称加密：通信双方都使用同一个密钥进行加密。这种方式虽然简单性能好，但是无法解决首次把密钥发给对方的问题，容易被黑客拦截密钥
- 非对称加密：由私钥+公钥组成的密钥对
  - 私钥加密的数据，只有公钥才能解密；公钥加密的数据，私钥才能解密
  - 通信双方都有自己的一套密钥对，通信前将自己的公钥发送给对方
  - 然后使用对方的公钥加密数据响应给对方，等对方收到后再用自己的私钥解密

非对称加密安全性更高，但是速度较慢，影响性能

https 将两种方式结合起来，将对称加密的密钥使用非对称加密的公钥进行加密，然后再发送出去，接收方使用自己的私钥解密得到对称加密的密钥

> 中间人问题：如果此时在双方之间存在一中间人，将原本双方通信互发的公钥换成自己的公钥，就可以轻松破解双方发送的消息

这个时候就需要一个安全的第三方来证明身份，所以就有了 CA 证书

为了防止 CA 证书被篡改，使用了另一种保护方案：数字签名

数字签名就是使用证书自带的 HASH 算法对证书内容进行计算得到一个摘要，再用 CA 的私钥进行加密组成最终的数字签名

> 当别人把他的证书发过来时，用同样的 HASH 算法得到信息摘要，然后再用 CA 的公钥对数字签名进行解密，得到 CA 创建的消息摘要，两者一对比就知道中间有没有被篡改了

通过这样的方式，https 最大化保证了通信的安全性

## GET 和 POST 的区别

get 和 post 请求本质上都是 TCP 链接，并无差别，但是由于 HTTP 的规定和浏览器、服务器的限制，导致它们在应用过程中体现出一些不同。

- get 是幂等的（也就是指无论调用这个 url 多少次，都不会有不同的结果的 HTTP 方法），post 非幂等
- get 请求能被缓存，post 不能
- 浏览器会限制 url 的长度，因此会影响 get 请求发送数据的长度
- get 请求只允许 ASCII 字符，post 请求无限制，也允许二进制数据
- post 请求相对更安全一些，因为 post 请求参数不会被存到浏览器历史中，但实际上都不安全，因为 HTTP 是明文传输

## HTTP2

- **二进制协议**：在 HTTP1.x 版本中，报文头信息必须是文本（ASCII 编码），报文体可以是文本或二进制。HTTP2 则是一个彻底的二进制协议，报文头和报文体都是二进制，并且统称为“帧”
- **多路复用**：在一个 TCP 连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送
- **数据流**：HTTP2 的数据包不按顺序发送，同一个连接里面连续的数据包可能属于不同请求，因此必须对数据包做标记，指出它属于哪个请求。HTTP2 的每个请求或响应的所有数据包成为一个数据流，都有独一无二的编号
- **头信息压缩**：HTTP1.x 每次请求都会附上头信息，很多字段都是重复的。HTTP2 一方面会将头信息压缩后发送，另一方面服务端和客户端会共同维护一张表，所有字段存入这个表中生成索引号，发送时只发送索引
- **服务器推送**：HTTP2 允许服务端未经请求主动向客户端发送资源，主动推送的是静态资源，与 websocket 发送的即时资源不同
