# HTTP/浏览器

## 从地址栏输入URL到呈现页面

1. 浏览器向DNS服务器获取URL中域名对应的IP地址
2. 建立TCP连接
3. 浏览器发出读取文件的请求
4. 服务器对浏览器请求做出响应，并把对应的html文本发送给浏览器
5. 浏览器渲染HTML并显示
6. 释放TCP连接

## 三次握手作用

**第一次**：客户端向服务端发送请求建立连接

**第二次**：服务端接收到客户端的请求后向客户端发送响应，这时服务端知道了客户端可以正常发送请求

**第三次**：客户端接收到响应后再次向服务端发送请求，这时客户端知道了服务端可以正常的接收和发送，服务端知道了客户端也可以正常接收，连接建立成功

## 四次挥手

**第一次**：客户端数据发送完成，向服务端发送释放连接的请求

**第二次**：服务端接收到连接释放请求后，发送一个回复的响应进入CLOSE-WAIT状态，此时客户端到服务端的连接释放，不再接受客户端的数据，但是因为TCP连接是双向的，服务端仍旧可以发送数据到客户端

**第三次**：服务端如果还有没发送完的数据会继续发送，发送完毕后向客户端发送释放连接的请求，然后服务端进入LAST-ACK状态

**第四次**：客户端接收到请求后，向服务端发送应答，客户端进入TIME-WAIT状态，该状态会持续2MSL（2倍的报文在网络中的生存时间），若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。

四次挥手是因为TCP连接是全双工的，所以需要双方分别释放连接，单独一方的连接释放，只代表不能再向对方发送数据，连接处于的是半释放的状态。

最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器端不能正常关闭。

## HTTP缓存
### 强缓存
强制缓存就是文件直接从缓存中获取，不需要发送请求。

http1.0时，使用Expires字段，表示文件过期时间（使用GMT标准时间格式，js可以通过`new Date().toUTCString()`得到，时间期限是服务器生成的，有误差，优先级比`cache-control`低）

http1.1引入了cache-control
-   max-age: 缓存过期时间，相对于请求时间（多少秒后过期）
-   public: 表示客户端和代理服务器都会缓存
-   private: 表示只在客户端缓存
-   no-cache: 协商缓存标识符，表示文件会被缓存但是需要和服务器协商
-   no-store: 表示文件不会被缓存

### 协商缓存
协商缓存就是文件已经被缓存了，但是否从缓存中读取是需要和服务器进行协商，具体如何协商要看请求头/响应头的字段设置。( 如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串，资源从缓存中读取）

利用Last-Modified/if-Modified-Since和Etag/if-None-Match这两对响应/请求头

**Last-Modified/if-Modified-Since**

**Etag/if-None-Match**




## HTTPS

https是安全版的http，因为http都是明文传输的，对于敏感信息的传输很不安全，https就是为了解决http的安全隐患而出现的

https的实现比较复杂，将对称加密的密钥使用非对称加密的公钥进行加密，在保证了通信效率的同时防止窃听，同时结合CA证书以及数字签名来最大程度的保证安全性

- 对称加密：通信双方都使用同一个密钥进行加密。这种方式虽然简单性能好，但是无法解决首次把密钥发给对方的问题，容易被黑客拦截密钥
- 非对称加密：由私钥+公钥组成的密钥对
  - 私钥加密的数据，只有公钥才能解密；公钥加密的数据，私钥才能解密
  - 通信双方都有自己的一套密钥对，通信前将自己的公钥发送给对方
  - 然后使用对方的公钥加密数据响应给对方，等对方收到后再用自己的私钥解密

非对称加密安全性更高，但是速度较慢，影响性能

https将两种方式结合起来，将对称加密的密钥使用非对称加密的公钥进行加密，然后再发送出去，接收方使用自己的私钥解密得到对称加密的密钥

> 中间人问题：如果此时在双方之间存在一中间人，将原本双方通信互发的公钥换成自己的公钥，就可以轻松破解双方发送的消息

这个时候就需要一个安全的第三方来证明身份，所以就有了CA证书

为了防止CA证书被篡改，使用了另一种保护方案：数字签名

数字签名就是使用证书自带的HASH算法对证书内容进行计算得到一个摘要，再用CA的私钥进行加密组成最终的数字签名

> 当别人把他的证书发过来时，用同样的HASH算法得到信息摘要，然后再用CA的公钥对数字签名进行解密，得到CA创建的消息摘要，两者一对比就知道中间有没有被篡改了

通过这样的方式，https最大化保证了通信的安全性

## GET和POST的区别
get和post请求本质上都是TCP链接，并无差别，但是由于HTTP的规定和浏览器、服务器的限制，导致它们在应用过程中体现出一些不同。
- get是幂等的（也就是指无论调用这个url多少次，都不会有不同的结果的HTTP方法），post非幂等
- get请求能被缓存，post不能
- 浏览器会限制url的长度，因此会影响get请求发送数据的长度
- get请求只允许ASCII字符，post请求无限制，也允许二进制数据
- post请求相对更安全一些，因为post请求参数不会被存到浏览器历史中，但实际上都不安全，因为HTTP是明文传输

## HTTP2
- **二进制协议**：在HTTP1.x版本中，报文头信息必须是文本（ASCII编码），报文体可以是文本或二进制。HTTP2则是一个彻底的二进制协议，报文头和报文体都是二进制，并且统称为“帧”
- **多路复用**：在一个TCP连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送
- **数据流**：
- **头信息压缩**：
- **服务器推送**：